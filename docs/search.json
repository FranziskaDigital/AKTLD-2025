[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Über dieses Dashboard",
    "section": "",
    "text": "Dieses Dashboard präsentiert die Ergebnisse eines Seminars, das im Rahmen des hochschulübergreifenden Masterstudiengangs „Digitale Methodik in den Geistes‑ und Kulturwissenschaften“ angeboten wurde. Ziel des Seminars war es, zentrale Konzepte statistischer Datenanalyse – Kategorien, eindimensionale Häufigkeitsverteilungen, Mittelwerte und Streuung, Maße der Konzentration, Stichprobe und Grundgesamtheit – sowie die Grundlagen und Werkzeuge der Datenvisualisierung anhand eines konkreten kulturwissenschaftlichen Fallbeispiels zu vermitteln."
  },
  {
    "objectID": "dashboard.html",
    "href": "dashboard.html",
    "title": "UNESCO Welterbestätten",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport plotly.express as px\n\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\n\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"], errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(subset=[\"name_en\", \"date_inscribed\", \"category\", \"latitude\", \"longitude\"]).reset_index(drop=True)\n\n# Farben für die einzelnen Kategorien festlegen\npalette = px.colors.qualitative.Plotly\nunique_cats = sorted(df[\"category\"].unique())\ncolor_map = {cat: palette[i % len(palette)] for i, cat in enumerate(unique_cats)}\ndf[\"color\"] = df[\"category\"].map(color_map)\n\n# Erstelle die Weltkarte\nfig = px.scatter_geo(\n    df,\n    lat=\"latitude\",\n    lon=\"longitude\",\n    hover_name=\"name_en\",\n    color=\"category\",\n    color_discrete_map=color_map,\n    projection=\"natural earth\",\n    title=\"UNESCO-Welterbestätten\",\n)\n\n# Anpassungen für die Karte\nfig.update_layout(\n    width=700,\n    height=400,\n    geo=dict(\n        showland=True,\n        landcolor=\"lightgray\",\n        countrycolor=\"gray\",\n        showframe=False,\n        showcoastlines=True,\n        coastlinecolor=\"gray\",\n        projection=dict(\n            type=\"equal earth\"\n        ),\n        center=dict(\n            lat=0,\n            lon=0\n        ),\n        lonaxis=dict(\n            showgrid=True,\n            gridwidth=0.5,\n            gridcolor=\"lightgray\"\n        ),\n        lataxis=dict(\n            showgrid=True,\n            gridwidth=0.5,\n            gridcolor=\"lightgray\"\n        )\n    )\n)\n\nfig.show()"
  },
  {
    "objectID": "dashboard.html#interaktive-karte",
    "href": "dashboard.html#interaktive-karte",
    "title": "UNESCO Welterbestätten",
    "section": "Interaktive Karte",
    "text": "Interaktive Karte\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\n\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\n\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"], errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(subset=[\"name_en\", \"date_inscribed\", \"category\", \"latitude\", \"longitude\"]).reset_index(drop=True)\n\n# Sortieren für richtigen Slider\ndf = df.sort_values(\"date_inscribed\")\ndf[\"date_inscribed\"] = df[\"date_inscribed\"].astype(int).astype(str)\n\n# Farben\npalette = px.colors.qualitative.Plotly\nunique_cats = sorted(df[\"category\"].unique())\ncolor_map = {cat: palette[i % len(palette)] for i, cat in enumerate(unique_cats)}\n\n# Plot erstellen\nfig = px.scatter_geo(\n    df,\n    lat=\"latitude\",\n    lon=\"longitude\",\n    hover_name=\"name_en\",\n    color=\"category\",\n    color_discrete_map=color_map,\n    projection=\"natural earth\",\n    animation_frame=\"date_inscribed\",\n    title=\"UNESCO-Welterbestätten mit Timeslider\",\n)\n\nfig.update_layout(\n    width=900,\n    height=500,\n    geo=dict(\n        showland=True,\n        landcolor=\"lightgray\",\n        countrycolor=\"gray\",\n        showframe=False,\n        showcoastlines=True,\n        coastlinecolor=\"gray\",\n        projection=dict(type=\"equal earth\"),\n        center=dict(lat=0, lon=0),\n        lonaxis=dict(showgrid=True, gridwidth=0.5, gridcolor=\"lightgray\"),\n        lataxis=dict(showgrid=True, gridwidth=0.5, gridcolor=\"lightgray\")\n    )\n)\n\nfig.update_layout(\n    sliders=[dict(currentvalue={\"prefix\": \"Jahr: \"})]\n)\n\nfig"
  },
  {
    "objectID": "dashboard.html#kumulierte-visualisierung",
    "href": "dashboard.html#kumulierte-visualisierung",
    "title": "UNESCO Welterbestätten",
    "section": "Kumulierte Visualisierung",
    "text": "Kumulierte Visualisierung\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\n\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\n\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"], errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(subset=[\"name_en\", \"date_inscribed\", \"category\", \"latitude\", \"longitude\"]).reset_index(drop=True)\n\n# Sortieren\ndf = df.sort_values(\"date_inscribed\")\n\n# Alle Jahre sammeln\nyears = sorted(df[\"date_inscribed\"].dropna().unique())\n\n# Kumulative Version des DataFrames erstellen\nframes = []\nfor year in years:\n    subset = df[df[\"date_inscribed\"] &lt;= year].copy()\n    subset[\"year\"] = year\n    frames.append(subset)\n\ndf_cum = pd.concat(frames, ignore_index=True)\ndf_cum[\"year\"] = df_cum[\"year\"].astype(int)\n\n# Farben\npalette = px.colors.qualitative.Plotly\nunique_cats = sorted(df[\"category\"].unique())\ncolor_map = {cat: palette[i % len(palette)] for i, cat in enumerate(unique_cats)}\n\n# Basis-Plot\nfig = px.scatter_geo(\n    df_cum,\n    lat=\"latitude\",\n    lon=\"longitude\",\n    hover_name=\"name_en\",\n    color=\"category\",\n    color_discrete_map=color_map,\n    projection=\"natural earth\",\n    animation_frame=\"year\",\n    title=\"UNESCO-Welterbestätten mit Timeslider (kumuliert)\",\n)\n\n# Kumulative Zählung vorbereiten\ncounts = df_cum.groupby(\"year\")[\"name_en\"].nunique().to_dict()\n\n# Frames mit Annotation ergänzen\nnew_frames = []\nfor fr in fig.frames:\n    year = int(fr.name)\n    count = counts[year]\n    fr.layout = go.Layout(\n        annotations=[\n            dict(\n                x=0.98, y=0.95, xref=\"paper\", yref=\"paper\",\n                text=f\"Gesamt: {count}\",\n                showarrow=False,\n                font=dict(size=20, color=\"black\"),\n                bgcolor=\"white\",\n                bordercolor=\"black\",\n                borderwidth=1,\n                opacity=0.8\n            )\n        ]\n    )\n    new_frames.append(fr)\nfig.frames = new_frames\n\n# Slider nur mit Jahren\nsteps = []\nfor year in years:\n    step = dict(\n        method=\"animate\",\n        args=[[str(year)],\n              dict(mode=\"immediate\", frame=dict(duration=500, redraw=True), transition=dict(duration=300))],\n        label=str(year)\n    )\n    steps.append(step)\n\nsliders = [dict(\n    active=0,\n    currentvalue={\"prefix\": \"Jahr: \"},\n    pad={\"t\": 50},\n    steps=steps\n)]\n\nfig.update_layout(\n    width=900,\n    height=500,\n    geo=dict(\n        showland=True,\n        landcolor=\"lightgray\",\n        countrycolor=\"gray\",\n        showframe=False,\n        showcoastlines=True,\n        coastlinecolor=\"gray\",\n        projection=dict(type=\"equal earth\"),\n        center=dict(lat=0, lon=0),\n        lonaxis=dict(showgrid=True, gridwidth=0.5, gridcolor=\"lightgray\"),\n        lataxis=dict(showgrid=True, gridwidth=0.5, gridcolor=\"lightgray\")\n    ),\n    sliders=sliders,\n    annotations=[dict(  # Startwert für erstes Jahr\n        x=0.98, y=0.95, xref=\"paper\", yref=\"paper\",\n        text=f\"Gesamt: {counts[years[0]]}\",\n        showarrow=False,\n        font=dict(size=20, color=\"black\"),\n        bgcolor=\"white\",\n        bordercolor=\"black\",\n        borderwidth=1,\n        opacity=0.8\n    )]\n)\n\nfig"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AKTLD 2025",
    "section": "",
    "text": "Diese Webseite mit einem Dashboard zum UNESCO-Weltkulturerbe wurde für die Jahrestagung des Arbeitskreises Theorie und Lehre der Denkmalpflege 2025 in Cottbus erstellt und dient der weiterführenden Information zum Posterbeitrag “Weltkulturerbe Digital – Seminar zur Einführung in quantitative Analysen und Visualisierungen digitaler Information”.\n\n\n\nPosterbeitrag AKTLD-2025\n\n\n\n\n\nPosterbeitrag AKTLD-2025"
  },
  {
    "objectID": "about.html#ausgangslage",
    "href": "about.html#ausgangslage",
    "title": "Über dieses Dashboard",
    "section": "Ausgangslage",
    "text": "Ausgangslage\nDen Ausgangspunkt bildete der UNESCO-Datensatz zum Weltkulturerbe, der grundsätzlich eine Vielzahl relevanter Informationen enthält – etwa die Bezeichnung der Welterbestätten, Geokoordinaten sowie die zugehöri- gen Welterbekategorien. Allerdings liegt dieser Datensatz in verschiedenen, größtenteils wenig verarbeiteten oder schwer weiterzuverarbeitenden Dateiformaten vor (u.a. xls, xlsx, xml, kml, GeoRSS), von denen einige proprietär oder für statistische Analysen ungeeignet sind. Im Kurs wurde zunächst das Microsoft-Format xlsx verwendet. Für weiterführende Analysen war eine tiefgreifende Datenbereinigung und -vorbereitung erforderlich. Auch die Umwandlung in ein offenes und maschinenlesbares csv-Format war notwendig, um die Daten in Analysewerkzeugen effizient nutzen zu können. Die anschließende Datenanreicherung mit Normdaten und die Bereinigung von Dubletten erwies sich als äußerst zeitintensiv und nahm mehrere Wochen in Anspruch. Erst nach Abschluss dieser umfassenden Aufbereitung konnte der Datensatz für statistische Auswertungen sinnvoll eingesetzt werden."
  },
  {
    "objectID": "about.html#analytische-schwerpunkte",
    "href": "about.html#analytische-schwerpunkte",
    "title": "Über dieses Dashboard",
    "section": "Analytische Schwerpunkte",
    "text": "Analytische Schwerpunkte\nIm Rahmen des Seminars wurden aus den gelesenen Texten Thesen abgeleitet und quantitativ ausgewertet. Dabei standen folgende Fragen im Mittelpunkt:\n\nEignung quantitativer Methoden für geistes‑ und kulturwissenschaftliche Fragestellungen.\n\nGeeignete Visualisierungsformen (z. B. Karten, Balken‑ und Liniendiagramme) versus solche, die potenziell irreführend sein können.\nKritische Reflexion über die Grenzen statistischer Modelle bei der Darstellung komplexer kulturhistorischer Prozesse."
  },
  {
    "objectID": "about.html#beitrag-zur-kulturerbeforschung",
    "href": "about.html#beitrag-zur-kulturerbeforschung",
    "title": "Über dieses Dashboard",
    "section": "Beitrag zur Kulturerbeforschung",
    "text": "Beitrag zur Kulturerbeforschung\nDurch die Verknüpfung geisteswissenschaftlicher Fragestellungen mit datengetriebenen Analysemethoden leistet das Projekt einen Beitrag zur Sichtbarmachung globaler Ungleichheiten im Welterbe‑Programm. Die resultierenden Auswertungen unterstützen Diskussionen über:\n\nSchutzprioritäten und Ressourcenallokation.\n\nRepräsentationslücken (z. B. Unterrepräsentation bestimmter Regionen oder Kulturen).\n\nZukünftige Ausrichtung der Welterbepolitik auf Basis evidenzbasierter Erkenntnisse."
  },
  {
    "objectID": "dashboard.html#überblick-statistiken-tabellen",
    "href": "dashboard.html#überblick-statistiken-tabellen",
    "title": "UNESCO Welterbestätten",
    "section": "Überblick-Statistiken (Tabellen)",
    "text": "Überblick-Statistiken (Tabellen)\nAlle relevanten Informationen auf einen BlicK: Größe des Datensatzes, Grundgrößen (Durchschnitts‑/Medianwerte etc.)\n\n\nCode\nimport pandas as pd\n\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\n\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"], errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(subset=[\"name_en\", \"date_inscribed\", \"category\", \"latitude\", \"longitude\"]).reset_index(drop=True)\n\n# Kennzahlen berechnen\ntotal_sites   = df[\"name_en\"].nunique()\ntotal_years   = df[\"date_inscribed\"].nunique()\nyears_range   = (df[\"date_inscribed\"].min(), df[\"date_inscribed\"].max())\nmean_lat      = df[\"latitude\"].mean()\nmean_lon      = df[\"longitude\"].mean()\nmedian_year   = df[\"date_inscribed\"].median()\n\n# Ergebnis‑DataFrame\nsummary_tbl = pd.DataFrame({\n    \"Kennzahl\": [\n        \"Gesamtzahl der Welterbestätten\",\n        \"Unterschiedliche Einschreibungsjahre\",\n        \"Einschreibungen‑Jahresbereich\",\n        \"Durchschnittlicher Breitengrad\",\n        \"Durchschnittlicher Längengrad\",\n        \"Median‑Einschreibungsjahr\"\n    ],\n    \"Wert\": [\n        total_sites,\n        total_years,\n        f\"{years_range[0]}–{years_range[1]}\",\n        f\"{mean_lat:.2f}°\",\n        f\"{mean_lon:.2f}°\",\n        int(median_year)\n    ]\n})\n\nsummary_tbl\n\n\n\n\n\n\n\n\n\n\nKennzahl\nWert\n\n\n\n\n0\nGesamtzahl der Welterbestätten\n1247\n\n\n1\nUnterschiedliche Einschreibungsjahre\n46\n\n\n2\nEinschreibungen‑Jahresbereich\n1978–2025\n\n\n3\nDurchschnittlicher Breitengrad\n28.86°\n\n\n4\nDurchschnittlicher Längengrad\n21.56°\n\n\n5\nMedian‑Einschreibungsjahr\n1999"
  },
  {
    "objectID": "dashboard.html#jahresverteilung-histogramm",
    "href": "dashboard.html#jahresverteilung-histogramm",
    "title": "UNESCO Welterbestätten",
    "section": "Jahresverteilung (Histogramm)",
    "text": "Jahresverteilung (Histogramm)\nDas Histogramm zeigt, in welchen Zeiträume besonders viele oder wenige Eintragungen in die Welterbeliste erfolgt sind.\n\n\nCode\nimport plotly.express as px\n\nfig_hist = px.histogram(\n    df,\n    x=\"date_inscribed\",\n    nbins=30,                     \n    title=\"Anzahl der UNESCO‑Welterbestätten pro Inskriptionsjahr\",\n    labels={\"date_inscribed\":\"Jahr der Aufnahme\", \"count\":\"Anzahl\"},\n    color_discrete_sequence=[\"steelblue\"]\n)\nfig_hist.update_layout(bargap=0.1, width=800, height=450)\nfig_hist.show()"
  },
  {
    "objectID": "dashboard.html#kategorien-entwicklung-im-verlauf-der-zeit-gestapletes-flächendiagramm",
    "href": "dashboard.html#kategorien-entwicklung-im-verlauf-der-zeit-gestapletes-flächendiagramm",
    "title": "UNESCO Welterbestätten",
    "section": "Kategorien-Entwicklung im Verlauf der Zeit (gestapletes Flächendiagramm)",
    "text": "Kategorien-Entwicklung im Verlauf der Zeit (gestapletes Flächendiagramm)\nDer Blick auf die Entwicklung der einzelnen Kategorien veranschaulicht, welchen Anteil die einzelne Kategorien (Kulturerbe, Naturerbe, Mischformen) im Zeitverlauf besitzen.\n\n\nCode\ncat_year = (\n    df.groupby([\"date_inscribed\", \"category\"])\n      .size()\n      .reset_index(name=\"count\")\n)\n\nfig_area = px.area(\n    cat_year,\n    x=\"date_inscribed\",\n    y=\"count\",\n    color=\"category\",\n    title=\"Entwicklung der Kategorien (Kulturerbe, Naturerbe, Mixed) über die Jahre\",\n    labels={\"date_inscribed\":\"Jahr\", \"count\":\"Anzahl\"},\n    color_discrete_map=color_map   \n)\nfig_area.update_layout(width=850, height=470)\nfig_area.show()"
  },
  {
    "objectID": "dashboard.html#geografische-konzentration-ginikoeffizient-lorenzkurve",
    "href": "dashboard.html#geografische-konzentration-ginikoeffizient-lorenzkurve",
    "title": "UNESCO Welterbestätten",
    "section": "Geografische Konzentration (Gini‑Koeffizient & Lorenz‑Kurve)",
    "text": "Geografische Konzentration (Gini‑Koeffizient & Lorenz‑Kurve)\nDer Gini‑Wert (0 = gleichmäßig, 1 = extrem ungleich) quantifiziert, ob UNESCO‑Stätten stark in wenigen Ländern konzentriert sind. Auf diese Weise kann ermittelt werden, ob die Welterbestätten ungleich verteilt sind.\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nif \"states_name_en\" in df.columns:\n    country_col = \"states_name_en\"\nelif \"country\" in df.columns:\n    country_col = \"country\"\nelse:\n    raise KeyError(\"Keine Länderspalte gefunden (states_name_en / country).\")\n\ncountry_counts = df[country_col].value_counts().sort_values(ascending=False)\n\n# Gini‑Berechnung\ndef gini(array):\n    \"\"\"Gini‑Koeffizient für 1‑D‑Array.\"\"\"\n    array = np.array(array, dtype=float)\n    if np.amin(array) &lt; 0:\n        array -= np.amin(array)                     \n    array = np.sort(array)\n    n = array.shape[0]\n    cumulative = np.cumsum(array)\n    gini_coef = (n + 1 - 2 * np.sum(cumulative) / cumulative[-1]) / n\n    return gini_coef\n\ngini_val = gini(country_counts.values)\n\n# Lorenz‑Kurve\ncum_counts = np.cumsum(country_counts.values) / country_counts.values.sum()\ncum_share  = np.arange(1, len(cum_counts)+1) / len(cum_counts)\n\nfig_gini = go.Figure()\nfig_gini.add_trace(go.Scatter(x=cum_share, y=cum_counts,\n                              mode=\"lines\", name=\"Lorenz‑Kurve\",\n                              line=dict(color=\"steelblue\")))\n# Diagonale (Gleichverteilung)\nfig_gini.add_trace(go.Scatter(x=[0,1], y=[0,1],\n                              mode=\"lines\", name=\"Perfekte Gleichverteilung\",\n                              line=dict(dash=\"dash\", color=\"gray\")))\nfig_gini.update_layout(\n    title=f\"Gini‑Koeffizient = {gini_val:.3f} – Ungleichheit der Verteilung nach Ländern\",\n    xaxis_title=\"Kumulativer Anteil der Länder\",\n    yaxis_title=\"Kumulativer Anteil der Stätten\",\n    width=800, height=460,\n    showlegend=True\n)\nfig_gini.show()"
  },
  {
    "objectID": "dashboard.html#heatmap-dichtekarte",
    "href": "dashboard.html#heatmap-dichtekarte",
    "title": "UNESCO Welterbestätten",
    "section": "Heatmap / Dichtekarte",
    "text": "Heatmap / Dichtekarte\nDie Heat‑Map stellt visuell dar, wo sich UNESCO‑Welterbestätten räumlich konzentrieren.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\n\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"], errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(\n    subset=[\"name_en\", \"date_inscribed\", \"category\", \"latitude\", \"longitude\"]\n).reset_index(drop=True)\n\n# 2‑D‑Histogram\nlat_bins = np.linspace(df[\"latitude\"].min(), df[\"latitude\"].max(), 120)\nlon_bins = np.linspace(df[\"longitude\"].min(), df[\"longitude\"].max(), 240)\nheatmap, lat_edges, lon_bins = np.histogram2d(df[\"latitude\"], df[\"longitude\"],\n                                             bins=[lat_bins, lon_bins])\n\n# Bin‑Mitte für Achsen‑Beschriftung\nx_mid = (lon_bins[:-1] + lon_bins[1:]) / 2\ny_mid = (lat_edges[:-1] + lat_edges[1:]) / 2\n\nfig = px.imshow(\n    heatmap,\n    labels=dict(x=\"Längengrad\", y=\"Breitengrad\", color=\"Anzahl\"),\n    x=x_mid,\n    y=y_mid,\n    color_continuous_scale=\"YlOrRd\",\n    origin=\"lower\",                 \n    title=\"Dichte der UNESCO‑Welterbestätten\",\n)\n\nfig.update_layout(width=850, height=460)\nfig.show()"
  },
  {
    "objectID": "dashboard.html#choroplethenkarte-anzahl-pro-land",
    "href": "dashboard.html#choroplethenkarte-anzahl-pro-land",
    "title": "UNESCO Welterbestätten",
    "section": "Choroplethen‑Karte: Anzahl pro Land",
    "text": "Choroplethen‑Karte: Anzahl pro Land\nGibt einen klaren, länderspezifischen Überblick darüber, welche Staaten besonders viele Welterbestätten besitzen.\n\n\nCode\nimport plotly.express as px\n\n# Aggregation pro Land\ncountry_agg = (\n    df.groupby(country_col)\n      .size()\n      .reset_index(name=\"count\")\n)\n\nfig_choro = px.choropleth(\n    country_agg,\n    locations=country_col,\n    locationmode=\"country names\",      \n    color=\"count\",\n    color_continuous_scale=\"Blues\",\n    title=\"Anzahl UNESCO‑Welterbestätten pro Land (Stand 2025)\",\n    labels={\"count\":\"Stätten\"}\n)\nfig_choro.update_layout(width=900, height=500)\nfig_choro.show()"
  },
  {
    "objectID": "dashboard.html#boxplot-breitengrad-nach-kategorie",
    "href": "dashboard.html#boxplot-breitengrad-nach-kategorie",
    "title": "UNESCO Welterbestätten",
    "section": "Box‑Plot: Breitengrad nach Kategorie",
    "text": "Box‑Plot: Breitengrad nach Kategorie\nZeigt, ob bestimmte Kategorien (z. Bsp. Naturebe) eher in bestimmten geographischen Zonen (höherer/niedrigerer Breitengrad) liegen.\n\n\nCode\nimport plotly.express as px\n\nfig_box = px.box(\n    df,\n    x=\"category\",\n    y=\"latitude\",\n    color=\"category\",\n    color_discrete_map=color_map,\n    title=\"Verteilung des Breitengrads je UNESCO‑Kategorie\",\n    labels={\"latitude\":\"Breitengrad\", \"category\":\"Kategorie\"}\n)\nfig_box.update_layout(width=800, height=460, showlegend=False)\nfig_box.show()"
  },
  {
    "objectID": "dashboard.html#korrelation-zwischen-einschreibungsjahr-und-geographischer-lage",
    "href": "dashboard.html#korrelation-zwischen-einschreibungsjahr-und-geographischer-lage",
    "title": "UNESCO Welterbestätten",
    "section": "Korrelation zwischen Einschreibungsjahr und geographischer Lage",
    "text": "Korrelation zwischen Einschreibungsjahr und geographischer Lage\nPrüft, ob neuere Einträge tendenziell in anderen geographischen Regionen liegen.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport scipy.stats as stats   \n\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\n\n\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"], errors=\"coerce\").astype(\"Int64\")\ndf[\"latitude\"]       = pd.to_numeric(df[\"latitude\"], errors=\"coerce\")\ndf[\"longitude\"]      = pd.to_numeric(df[\"longitude\"], errors=\"coerce\")\n\ndf = df.dropna(subset=[\"name_en\", \"date_inscribed\", \"category\",\n                       \"latitude\", \"longitude\"]).reset_index(drop=True)\n\n\n# Pearson‑Korrelationen\ncorr_lat, p_lat = stats.pearsonr(df[\"date_inscribed\"], df[\"latitude\"])\ncorr_lon, p_lon = stats.pearsonr(df[\"date_inscribed\"], df[\"longitude\"])\n\n# Lineare Regression (SciPy → linregress)\n#    y = a * x + b   (hier: Breitengrad als y, Jahr als x)\nslope, intercept, r_value, p_value, std_err = stats.linregress(\n    df[\"date_inscribed\"], df[\"latitude\"]\n)\n\n# Werte für die Regressionsgerade erzeugen\nx_line = np.linspace(df[\"date_inscribed\"].min(),\n                     df[\"date_inscribed\"].max(), 500)\ny_line = slope * x_line + intercept\n\n# Scatter‑Plot + Regressionsgerade\nfig_scatter = px.scatter(\n    df,\n    x=\"date_inscribed\",\n    y=\"latitude\",\n    hover_name=\"name_en\",\n    color=\"category\",           \n    color_discrete_map=color_map if 'color_map' in globals() else None,\n    title=(\n        f\"Zusammenhang Jahr ↔ Breitengrad (r = {corr_lat:.2f}, \"\n        f\"p = {p_lat:.3g})\"\n    ),\n    labels={\"date_inscribed\": \"Einschreibungsjahr\", \"latitude\": \"Breitengrad\"}\n)\n\n# Regressionsgerade als separaten Trace hinzufügen\nfig_scatter.add_scatter(\n    x=x_line,\n    y=y_line,\n    mode=\"lines\",\n    line=dict(color=\"black\", width=2, dash=\"dash\"),\n    name=f\"Ols‑Fit (y = {slope:.4f}·x + {intercept:.1f})\"\n)\n\nfig_scatter.update_layout(\n    width=850,\n    height=460,\n    legend=dict(title=\"Kategorie\")\n)\n\nfig_scatter.show()"
  },
  {
    "objectID": "dashboard.html#cluster-analyse-der-standorte-k-means",
    "href": "dashboard.html#cluster-analyse-der-standorte-k-means",
    "title": "UNESCO Welterbestätten",
    "section": "Cluster-Analyse der Standorte (k-Means)",
    "text": "Cluster-Analyse der Standorte (k-Means)\nIdentifiziert räumliche Hot‑Spots und liefert eine mögliche Basis für regionale Netzwerk‑ oder Kooperations‑Strategien.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nfrom scipy.cluster.vq import kmeans2\n\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\n\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"], errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(\n    subset=[\"name_en\", \"date_inscribed\", \"category\", \"latitude\", \"longitude\"]\n).reset_index(drop=True)\n\n\ncoords = df[[\"latitude\", \"longitude\"]].values\n\ncoords_mean = coords.mean(axis=0)\ncoords_std  = (coords - coords_mean) / coords.std(axis=0)\n\nk = 5\ncentroids, labels = kmeans2(coords_std, k, iter=100, minit='points')\n\ndf[\"cluster\"] = labels\n\n\ncluster_palette = px.colors.sequential.Plasma[:k]          \ncluster_map = {i: cluster_palette[i] for i in range(k)}\ndf[\"cluster_color\"] = df[\"cluster\"].map(cluster_map)\n\n\nfig_cluster = px.scatter_geo(\n    df,\n    lat=\"latitude\",\n    lon=\"longitude\",\n    hover_name=\"name_en\",\n    color=\"cluster\",                 \n    color_discrete_map=cluster_map,  \n    projection=\"natural earth\",\n    title=f\"Geographische Cluster (k‑Means, k={k}) der UNESCO‑Welterbestätten\"\n)\n\nfig_cluster.update_layout(width=900, height=500)\nfig_cluster.show()"
  },
  {
    "objectID": "dashboard.html#interaktive-sidebar",
    "href": "dashboard.html#interaktive-sidebar",
    "title": "UNESCO Welterbestätten",
    "section": "Interaktive Sidebar",
    "text": "Interaktive Sidebar\n\n\nCode\nimport pandas as pd\nimport plotly.express as px\nimport ipywidgets as widgets\nfrom IPython.display import display\n\n# -------------------------------------------------\n# Daten laden & bereinigen (wie in deinen anderen Blöcken)\n# -------------------------------------------------\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"],\n                                     errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(subset=[\"name_en\",\"date_inscribed\",\"category\",\n                       \"latitude\",\"longitude\"]).reset_index(drop=True)\n\n# -------------------------------------------------\n# Widgets definieren\n# -------------------------------------------------\ncat_options = sorted(df[\"category\"].unique())\ncat_widget = widgets.SelectMultiple(\n    options=cat_options,\n    value=cat_options,               # voreingestellt: alles ausgewählt\n    description='Kategorie:',\n    rows=6,\n    layout=widgets.Layout(width='250px')\n)\n\nyear_range = (int(df[\"date_inscribed\"].min()),\n              int(df[\"date_inscribed\"].max()))\nyear_slider = widgets.IntRangeSlider(\n    value=year_range,\n    min=year_range[0],\n    max=year_range[1],\n    step=1,\n    description='Jahre:',\n    continuous_update=False,\n    layout=widgets.Layout(width='400px')\n)\n\n# -------------------------------------------------\n# Update‑Funktion: erzeugt das Plotly‑Figure\n# -------------------------------------------------\ndef update_plot(change=None):\n    # Filter anwenden\n    filtered = df[\n        (df[\"category\"].isin(cat_widget.value)) &\n        (df[\"date_inscribed\"] &gt;= year_slider.value[0]) &\n        (df[\"date_inscribed\"] &lt;= year_slider.value[1])\n    ]\n    # Scatter‑Karte (kann natürlich jede andere Figure sein)\n    fig = px.scatter_geo(\n        filtered,\n        lat=\"latitude\",\n        lon=\"longitude\",\n        hover_name=\"name_en\",\n        color=\"category\",\n        projection=\"natural earth\",\n        title=\"UNESCO‑Welterbestätten (gefiltert)\"\n    )\n    fig.update_layout(width=850, height=460, margin=dict(l=0, r=0, t=40, b=0))\n    fig.show()\n\n# -------------------------------------------------\n# Beobachter registrieren (wird bei jeder Änderung getriggert)\n# -------------------------------------------------\ncat_widget.observe(update_plot, names='value')\nyear_slider.observe(update_plot, names='value')\n\n# -------------------------------------------------\n# Layout: Sidebar + Plot\n# -------------------------------------------------\nsidebar = widgets.VBox([cat_widget, year_slider])\ndisplay(sidebar)\n\n# Initiales Plot\nupdate_plot()"
  },
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "Mein Dashboard",
    "section": "",
    "text": "import pandas as pd\nimport plotly.express as px\nimport ipywidgets as widgets\nfrom IPython.display import display\n\n# -------------------------------------------------\n# Daten laden & bereinigen (wie in deinen anderen Blöcken)\n# -------------------------------------------------\nCSV_PATH = \"World-Heritage-2025.csv\"\ndf = pd.read_csv(CSV_PATH)\ndf[\"date_inscribed\"] = pd.to_numeric(df[\"date_inscribed\"],\n                                     errors=\"coerce\").astype(\"Int64\")\ndf = df.dropna(subset=[\"name_en\",\"date_inscribed\",\"category\",\n                       \"latitude\",\"longitude\"]).reset_index(drop=True)\n\n# -------------------------------------------------\n# Widgets definieren\n# -------------------------------------------------\ncat_options = sorted(df[\"category\"].unique())\ncat_widget = widgets.SelectMultiple(\n    options=cat_options,\n    value=cat_options,               # voreingestellt: alles ausgewählt\n    description='Kategorie:',\n    rows=6,\n    layout=widgets.Layout(width='250px')\n)\n\nyear_range = (int(df[\"date_inscribed\"].min()),\n              int(df[\"date_inscribed\"].max()))\nyear_slider = widgets.IntRangeSlider(\n    value=year_range,\n    min=year_range[0],\n    max=year_range[1],\n    step=1,\n    description='Jahre:',\n    continuous_update=False,\n    layout=widgets.Layout(width='400px')\n)\n\n# -------------------------------------------------\n# Update‑Funktion: erzeugt das Plotly‑Figure\n# -------------------------------------------------\ndef update_plot(change=None):\n    # Filter anwenden\n    filtered = df[\n        (df[\"category\"].isin(cat_widget.value)) &\n        (df[\"date_inscribed\"] &gt;= year_slider.value[0]) &\n        (df[\"date_inscribed\"] &lt;= year_slider.value[1])\n    ]\n    # Scatter‑Karte (kann natürlich jede andere Figure sein)\n    fig = px.scatter_geo(\n        filtered,\n        lat=\"latitude\",\n        lon=\"longitude\",\n        hover_name=\"name_en\",\n        color=\"category\",\n        projection=\"natural earth\",\n        title=\"UNESCO‑Welterbestätten (gefiltert)\"\n    )\n    fig.update_layout(width=850, height=460, margin=dict(l=0, r=0, t=40, b=0))\n    fig.show()\n\n# -------------------------------------------------\n# Beobachter registrieren (wird bei jeder Änderung getriggert)\n# -------------------------------------------------\ncat_widget.observe(update_plot, names='value')\nyear_slider.observe(update_plot, names='value')\n\n# -------------------------------------------------\n# Layout: Sidebar + Plot\n# -------------------------------------------------\nsidebar = widgets.VBox([cat_widget, year_slider])\ndisplay(sidebar)\n\n# Initiales Plot\nupdate_plot()"
  }
]